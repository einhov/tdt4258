\chapter{Methodology}

\section{PTXdist and Linux}

\subsection{The build system}

Using the PTXdist build system proved to be a quite simple process. All commands
given to the build system are invoked through the \texttt{ptxdist} executable.
Before we could invoke the build system on the support files, we had to
configure PTXdist to use the correct configurations \cite{TDT4528Compendium}.
This was done by invoking the \texttt{ptxdist select <ptxconfig>},
\texttt{ptxdist platform <platformconfig>} and \texttt{ptxdist toolchain <path
to toolchain>} commands with their respective arguments. After configuring
PTXdist, to get the initial support files compiled and flashed all we found
necessary to do was to invoke \texttt{ptxdist go}, \texttt{ptxdist images} and
\texttt{ptxdist test flash-all}. These commands respectively built and installed
all selected packages that had been configured, generated images ready to be
flashed onto the development board, and flashed all the images to the board.

The initial build and flash took a significant amount of time, so luckily the
entire build is not required for changes to the driver or the game. Instead,
individual packages could be updates by cleaning the previously built package
with \texttt{ptxdist clean <package>}, compile it with \texttt{ptxdist compile
<package>}, install it onto the root filesystem with \texttt{ptxdist
targetinstall <package>} and finally flash only the root filesystem to the
development board with \texttt{ptxdist test flash-romfs}. This made testing
changes to our code iteratively a more pleasant process it would have been if
rebuilding and reflashing everything had been required.

\subsection{Interacting with Linux}

With Linux flashed onto the development board and a terminal emulator
communicating over the serial connection running on our development system, we
got the kernel boot log and eventually got to a shell prompt. From there we
started the game executable by invoking \texttt{game} and loaded the gamepad
kernel module with \texttt{modprobe driver-gamepad}.

\section{Implementing the Device Driver}

While the ultimate goal of the device driver, namely accessing hardware
registers to read gamepad data, is rather simple, the matter is complicated a
bit by the necessity to work with the abstraction layers of the operating
system. The driver module must implement interfaces imposed by the kernel in
order to expose its own functionality to the rest of the system.

\subsection{Init, Exit and Boilerplate}

The main entry and exit points for the module are the gamepad\_init and
gamepad\_cleanup functions. These two functions are exported from the module
with the module\_init and module\_exit macros and are called when the module is
loaded and unloaded, respectively. In gamepad\_init we set up the driver,
allocate resources and configure the GPIO hardware. In gamepad\_cleanup we free
our allocated resources and make sure the system will be in a valid state after
the module has been unloaded. The MODULE\_DESCRIPTION and MODULE\_LICENSE macros
are also used to encode a description and code licensing information in the
module.

\subsection{Adding a Device}

Information about our device is stored in a few global variables in the module.
\texttt{dev\_t dev} will hold the \emph{device numbers} for our device.  A
second variable \texttt{struct cdev cdev} will hold information about our
character device. A third variable \texttt{struct class *cl} will contain a
pointer to a \emph{class structure}. Fourthly, a variable \texttt{struct
file\_operations gamepad\_fops} holds function pointers to our character
device's file operation functions.

The first step of adding a device to the system, is to have a pair of numbers
allocated for our new device. This is done by calling:

\begin{lstlisting}
	int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,
		unsigned int count, char *name):
\end{lstlisting}

This function allocates a range of \texttt{count} minor device numbers from a
base of \texttt{firstminor} for a single dynamically allocated major device
number, storing the major number and first minor number in dev. The character
device structure \texttt{cdev} is together with a pointer to
\texttt{gamepad\_fops} sent as arguments to:

\begin{lstlisting}
	void cdev_init(struct cdev *cdev,
		struct file_operations *fops);
\end{lstlisting}

This initialises our character device structure, registering it with the correct
file operations. The next step is to add the character device to the system.
This is done by calling:

\begin{lstlisting}
	int cdev_add(struct cdev *dev, dev_t num,
		unsigned int count);
\end{lstlisting}

At this point the character device exists in the system and can be accessed by
user applications if they access a device node with the major and minor number
of the device. A final step in the initialisation of the device is done to make
the device node appear in the file hierarchy. A class structure is created with:

\begin{lstlisting}
	struct class *class_create(struct module *owner,
		const char *name);
\end{lstlisting}

And the device is finally created with:

\begin{lstlisting}
	struct device *device_create(struct class *class,
		struct device *parent, dev_t devt, void *drvdata,
		const char *fmt, ...);
\end{lstlisting}

Passing in our class structure and device numbers. \texttt{parent} and
\texttt{drvdata} are unused, so we pass in \texttt{NULL} for those. At this
point our gamepad driver has a character device registered with the kernel and
there is a device node in the file hierarchy for the device.

At module unload we need to destroy our device node and unregister the character
device numbers. This is done in \texttt{gamepad\_cleanup} and is quite simple.
Basically, every step done in \texttt{gamepad\_init} is undone in reverse order.
The device is destroyed with:

\begin{lstlisting}
	void device_destroy(struct class *class, dev_t devt);
\end{lstlisting}

The class is then destroyed with:

\begin{lstlisting}
	void class_destroy(struct class *cls);
\end{lstlisting}

Then the character device is deleted:

\begin{lstlisting}
	void cdev_del(struct cdev *);
\end{lstlisting}

And finally the character device number is unregistered:

\begin{lstlisting}
	void unregister_chrdev_region(dev_t	from, unsigned count);
\end{lstlisting}

\subsection{Accessing GPIO, Interrupts and Asynchronous Input/Output}

\subsubsection{Reading from the Device}

So there is a character device responding with data when read, but where that
data comes from hasn't been mentioned yet. The data comes from the function set
to the \texttt{read} field of the \texttt{gamepad\_fops} structure. In our
driver this function is

\begin{lstlisting}
	static ssize_t gamepad_read(struct file *filp,
		char __user *buf, size_t count, loff_t *offp)
\end{lstlisting}

Of its parameters, only \texttt{buf} and \texttt{count} are used. \texttt{buf}
is a pointer to a buffer in userspace where data should be transferred.
\texttt{count} is the maximum amount of bytes that should be read into the
buffer. The return value of the function is how many bytes were stored into the
user's buffer. Our driver stores the gamepad status in a global variable
\texttt{uint8\_t status}, so all the \texttt{gamepad\_read} function needs to do
is to copy the value of that one byte into the user's buffer. The driver should
not attempt to write directly into the buffer through the pointer, but rather
use an existing function in the kernel to copy data from the kernel into user
memory:

\begin{lstlisting}
	unsigned long copy_to_user(void __user *to,
	 	const void *from, unsigned long n);
\end{lstlisting}

Where \texttt{to} is \texttt{buf}, \texttt{from} is \texttt{\&status} and
\texttt{n} is 1.

\subsubsection{Hardware IO and Interrupts}

So we can read the \texttt{status} variable from the user application through
the character device, but we still need to read the status from the gamepad into
\texttt{status}. This is done in much the same way as in exercise 2, the GPIO
hardware is initialised by configuring the correct hardware registers. We wish
for the GPIO hardware to issue interrupts on button presses, so in addition to
enabling the GPIO pins we also configure and enable interrupts. In exercise 2 we
wrote directly to the hardware registers. This is not a good idea in a Linux
driver, where the standard interfaces should be utilised to play nicely with
other parts of the system. While it is technically possible to simply write
directly to the hardware registers in this case, due to the microcontroller's
lack of an MCU, we have attempted to follow the standard procedures for writing
to hardware. This procedure involves requesting a region of I/O memory and
remapping the area into memory. This last step does essentially nothing on this
particular system, as the microcontroller has no concept of virtual memory. As a
result the memory area will simple be remapped to its original location. Due to
portability it is still recommended to follow this procedure, however. The two
functions called to achieve this are:

\begin{lstlisting}
	struct resource *request_mem_region(unsigned long start,
		unsigned long len, char *name);

	void *ioremap_nocache(unsigned long phys_addr,
		unsigned long size);
\end{lstlisting}

The pointer to the remapped memory region is stored in a global variable
\texttt{volatile struct efm32gg\_gpio *GPIO}. The \texttt{struct efm32gg\_gpio}
structure describes the layout of the GPIO hardware registers. With the hardware
registers requested and mapped, we can start configuring the GPIO hardware.
Instead of dereferencing \texttt{GPIO} directly, we use another kernel function
, \texttt{iowrite32}, designed to write to I/O memory:

\begin{lstlisting}
	/* configure pins */
	iowrite32(0x33333333, &GPIO->PC.MODEL);
    iowrite32(0xff, &GPIO->PC.DOUT);

	/* configure pin interrupt */
    iowrite32(0x22222222, &GPIO->EXTIPSELL);
    iowrite32(0xff, &GPIO->EXTIFALL);
    iowrite32(0xff, &GPIO->EXTIRISE);

	/* enable gpio interrupts */
    iowrite32(0xff, &GPIO->IEN);
    iowrite32(0xff, &GPIO->IFC);
\end{lstlisting}

The GPIO hardware is now configured and issuing interrupts on button presses
from the gamepad, but we still need to register the interrupt requests with
Linux and tell it what we want to have done when it receives the interrupt. This
is done with:

\begin{lstlisting}
	request_irq(unsigned int irq, irq_handler_t handler,
		unsigned long flags, const char *name, void *dev);
\end{lstlisting}

\texttt{irq} is the number of the interrupt request we wish to register. The
relevant numbers for GPIO even and GPIO odd interrupts are supplied in the
TDT4258 compendium \cite{TDT4528Compendium}. \texttt{handler} is a function
pointer to a callback function which will be invoked when an interrupt request
is fired. We set this to a function in our module named
\texttt{gamepad\_handler}. The interrupt handler uses I/O access functions to
read the status of the controller into \texttt{status} and clear the GPIO
interrupt flags.

Resources allocated to the driver for accessing the hardware registers should
also be freed on module unload. This is also done in \texttt{gamepad\_cleanup}.
Firstly by clearing \texttt{GPIO->IEN} to disable interrupts from the GPIO, then
by calling the following function to free the interrupt request lines we
requested from the kernel:

\begin{lstlisting}
	void free_irq(unsigned int irq, void *dev_id);
\end{lstlisting}

The mapped GPIO hardware registers are subsequently unmapped with:

\begin{lstlisting}
	void iounmap(void * addr);
\end{lstlisting}

And the GPIO hardware memory region is released with:

\begin{lstlisting}
	void release_mem_region(unsigned long start,
		unsigned long len);
\end{lstlisting}

\subsubsection{Asynchronous Input/Output}

We wish for the device driver to be able to signal the user application whenever
a GPIO interrupt occurs. This is achieved in our driver using asynchronous
notification with the SIGIO signal. There is very little additional code that
needs to be added for the device driver to have this functionality. A global
\texttt{struct fasync\_struct *fasync\_queue} is declared to hold a queue of
processes that should be notified of an interrupt. In \texttt{gamepad\_fops} the
\texttt{fasync} field is set to a function \texttt{gamepad\_fasync} and the
\texttt{release} field is set to a function \texttt{gamepad\_release}.
\texttt{gamepad\_fasync} is then invoked every time a user process enables or
disables asynchronous notifications from the file descriptor to our device
driver. The function uses a helper function called \texttt{fasync\_helper} which
adds the process to or removes the process from the queue.
\texttt{gamepad\_fasync} is also issued from \texttt{gamepad\_release}, so that
processes are removed from the queue if they close the device driver. Finally,
in the \texttt{gamepad\_handler} we issue the signal to all listening processes
by invoking:

\begin{lstlisting}
	void kill_fasync(struct fasync_struct **fa,
		int sig, int band);
\end{lstlisting}

With a \texttt{sig} of \texttt{SIGIO}. As a result, all listening processes
receive a SIGIO signal.

\section{Implementing the Game}

The game consists of three scenes; an intro scene, the game scene and an ending
scene. Relevant aspects of each scene will be discussed in this section, but
first some words about initialisation of the program and receiving input.

\subsection{Initialisation and Input}

The game uses both the framebuffer and the gamepad driver. The framebuffer is
initialised in \texttt{framebuffer\_init} in \texttt{graphics.c}. The famebuffer
device, \texttt{/dev/fb0} is opened with:

\begin{lstlisting}
	int open(const char *pathname, int flags);
\end{lstlisting}

With flags of \texttt{O\_RDWR} for both read and write access. The framebuffer
is then mapped into the game's process' memory with:

\begin{lstlisting}
	void *mmap(void *addr, size_t length, int prot,
		int flags, int fd, off_t offset);
\end{lstlisting}

The returned pointer can then be used to directly access the framebuffer as
regular memory in C. After the framebuffer has been written to, we issue an
\texttt{ioctl} call on the framebuffer's file descriptor with a command of
0x4680 and an argument of a \texttt{struct fb\_copyarea*} which describes to get
the modified area of the framebuffer drawn to the LCD.

The gamepad device is similarily opened in \texttt{game.c}, with flag
\texttt{O\_RDONLY} since the gamepad driver doesn't support writes. A signal
handler for the \texttt{SIGIO} signal is registered with the following function:

\begin{lstlisting}
	int sigaction(int sig, const struct sigaction *restrict act,
	           struct sigaction *restrict oact);
\end{lstlisting}

Sending in a \texttt{struct sigaction*} with its \texttt{sa\_handler} field set
to our signal handler function \texttt{gamepad\_handler}. The gamepad handler
reads the status of the controller from the opened gamepad device and invokes
the input function for the currently active scene. The \texttt{fcntl} function
is then invoked on the gamepad's file descriptor to set the owning process ID of
the descriptor to the current process' ID and enables the \texttt{FASYNC} flag
of the file. The game now has asynchronous I/O from the gamepad driver.

\subsection{Intro}

The intro scene is, obviously, the first scene the game enters. When the intro
is initialised it draws a background image over the entire display with a call
to \texttt{draw\_image}. \texttt{draw\_image} draws an image to the framebuffer
at a specified location on the display. This is implemented as a loop over each
row of the image where each row is copied into the framebuffer with
\texttt{memcpy}. After the loop is finished, \texttt{ioctl} is invoked to update
the display. After the background has been drawn, two images with text are
overlayed on the background in an animation. Every frame a line of the image is
drawn into the framebuffer and displayed. If the microcontroller were left to
run the code as fast as it could, it would not be much of an animation.
Therefore, a delay is introduced between every frame, by invoking the
\texttt{usleep} function. This function puts the calling thread to sleep for a
specified amount of microseconds, or until the program receives a signal.
Sleeping the game thread instead of waiting in a loop gives the Linux system the
opportunity to put the CPU into low energy modes, saving energy. Once the
animation has finished, the intro scene enters an idle state where the thread is
put to sleep for 1 second at a time.

\subsection{Game}

After the intro scene the game enters the game scene. There is no continuous
animation during this scene. At entry to the scene, a sidebar image is drawn on
the left with \texttt{draw\_image}, a \(6 \times 6\) grid of tiles is drawn on
the right and a selection cursor is drawn on the upper left tile. The tiles are
drawn with \texttt{refresh\_tile}, which ultimately invokes
\texttt{draw\_image}, sending in an image of the dog tile if tile is open
according to the game state or an image of of a dog paw impression on wood if
the tile is closed. The cursor is drawn by \texttt{draw\_cursor}, which draws
lines of a solid colour along the edges of the tile by directly setting values
in a loop. As the cursor is moved around the board, the tile of the cursor's
previous location is redrawn with \texttt{refresh\_tile} to remove the cursor
from the old tile and the cursor is drawn over the new location's tile, again
with \texttt{draw\_cursor}.

\subsection{Ending}

After the game scene comes an ending scene. The ending scene is the most
graphically intense scene. As with the intro scene, the ending scene has a
background drawn over the entire scene and an animation is played over it.
\texttt{usleep} is again used to sleep in between each frame. The animation
played played during the ending scene is a balloon image with transparent pixels
floating over the background. The balloon is drawn with a function
\texttt{blit}, which draws and image to the framebuffer, but leaves the
framebuffer alone if the pixel in the image has a certain value. At every new
frame, the damage from the old balloon is repaired before drawing the balloon in
its new position over the background again. In the initial version of this
scene, the damaged area of the background was repaired by redrawing the
background over the entire rectangle of the old balloon. While this worked, it
caused noticable flickering on the balloon as the background got drawn over the
location of the new balloon. Through some more work we ended up with the
\texttt{blit\_repair\_background} which, based on the old balloon position and
the new balloon position, only repairs the background where the old balloon has
left it damaged and the new balloon does not cover. Using this function, the
animation shows no flickering.

\section{Tickless Idle}

As the Linux system controls most of the hardware for us, we didn't find much we
could try to do in our code to lower power consumption, apart from sleeping in
the game, limit draws to the display to what is necessary, and not constantly
poll the gamepad driver for updates. We tried one energy consumption measure,
which is to enable tickless idle in the Linux kernel. What this does is that
instead of having the kernel interrupted by a timer at a set frequency, the
kernel schedules the next time it wants to be interrupted. If the system has
little to do, for instance if it is idle in our game scene waiting for input,
the kernel could most likely schedule interrupts far less frequently than the
fixed timer and thus keep the CPU in a lower energy mode for larger periods of
time. To enable tickless idle we used \texttt{ptxdist kernelconfig} to enter the
kernel configuration menu, enabled ticlkless idle and recompiled the kernel.

\section{Testing}

In earlier exercises we mostly employed the \texttt{gdb} tool for debugging our
code. For the system used in this exercise, debugging with \texttt{gdb} is not
available without some extra work, which we never found the need to put in. We
managed to debug the code sufficiently with print statements and inspection of
the display. For energy consumption measurements we employed the eAProfiler
tool.
