\chapter{Methodology}

\section{PTXdist and Linux}

\subsection{The build system}

Using the PTXdist build system proved to be a quite simple process. All commands
given to the build system are invoked through the \texttt{ptxdist} executable.
Before we could invoke the build system on the support files, we had to
configure PTXdist to use the correct configurations. This was done by invoking
the \texttt{ptxdist select <ptxconfig>}, \texttt{ptxdist platform
<platformconfig>} and \texttt{ptxdist toolchain <path to toolchain>} commands
with their respective arguments. After configuring PTXdist, to get the initial
support files compiled and flashed all we found necessary to do was to invoke
\texttt{ptxdist go}, \texttt{ptxdist images} and \texttt{ptxdist test
flash-all}. These commands respectively built and installed all selected
packages that had been configured, generated images ready to be flashed onto the
development board, and flashed all the images to the board.

The initial build and flash took a significant amount of time, so luckily the
entire build is not required for changes to the driver or the game. Instead,
individual packages could be updates by cleaning the previously built package
with \texttt{ptxdist clean <package>}, compile it with \texttt{ptxdist compile
<package>}, install it onto the root filesystem with \texttt{ptxdist
targetinstall <package>} and finally flash only the root filesystem to the
development board with \texttt{ptxdist test flash-romfs}. This made testing
changes to our code iteratively a more pleasant process it would have been if
rebuilding and reflashing everything had been required.

\subsection{Interacting with Linux}

With Linux flashed onto the development board and a terminal emulator
communicating over the serial connection running on our development system, we
got the kernel boot log and eventually got to a shell prompt. From there we
started the game executable by invoking \texttt{game} and loaded the gamepad
kernel module with \texttt{modprobe driver-gamepad}.

\section{Implementing the Device Driver}

While the ultimate goal of the device driver, namely accessing hardware
registers to read gamepad data, is rather simple, the matter is complicated a
bit by the necessity to work with the abstraction layers of the operating
system. The driver module must implement interfaces imposed by the kernel in
order to expose its own functionality to the rest of the system.

\subsection{Init, Exit and Boilerplate}

The main entry and exit points for the module are the gamepad\_init and
gamepad\_cleanup functions. These two functions are exported from the module
with the module\_init and module\_exit macros and are called when the module is
loaded and unloaded, respectively. In gamepad\_init we set up the driver,
allocate resources and configure the GPIO hardware. In gamepad\_cleanup we free
our allocated resources and make sure the system will be in a valid state after
the module has been unloaded. The MODULE\_DESCRIPTION and MODULE\_LICENSE macros
are also used to encode a description and code licensing information in the
module.

\subsection{Adding a Device}

Information about our device is stored in a few global variables in the module.
\texttt{dev\_t dev} will hold the \emph{device numbers} for our device.  A
second variable \texttt{struct cdev cdev} will hold information about our
character device. A third variable \texttt{struct class *cl} will contain a
pointer to a \emph{class structure}. Fourthly, a variable \texttt{struct
file\_operations gamepad\_fops} holds function pointers to our character
device's file operation functions.

The first step of adding a device to the system, is to have a pair of numbers
allocated for our new device. This is done by calling:

\begin{lstlisting}
	int alloc_chrdev_region(dev_t *dev, unsigned int firstminor,
		unsigned int count, char *name):
\end{lstlisting}

This function allocates a range of \texttt{count} minor device numbers from a
base of \texttt{firstminor} for a single dynamically allocated major device
number, storing the major number and first minor number in dev. The character
device structure \texttt{cdev} is together with a pointer to
\texttt{gamepad\_fops} sent as arguments to:

\begin{lstlisting}
	void cdev_init(struct cdev *cdev,
		struct file_operations *fops);
\end{lstlisting}

This initialises our character device structure, registering it with the correct
file operations. The next step is to add the character device to the system.
This is done by calling:

\begin{lstlisting}
	int cdev_add(struct cdev *dev, dev_t num,
		unsigned int count);
\end{lstlisting}

At this point the character device exists in the system and can be accessed by
user applications if they access a device node with the major and minor number
of the device. A final step in the initialisation of the device is done to make
the device node appear in the file hierarchy. A class structure is created with:

\begin{lstlisting}
	struct class *class_create(struct module *owner,
		const char *name);
\end{lstlisting}

And the device is finally created with:

\begin{lstlisting}
	struct device *device_create(struct class *class,
		struct device *parent, dev_t devt, void *drvdata,
		const char *fmt, ...);
\end{lstlisting}

Passing in our class structure and device numbers. \texttt{parent} and
\texttt{drvdata} are unused, so we pass in \texttt{NULL} for those. At this
point our gamepad driver has a character device registered with the kernel and
there is a device node in the file hierarchy for the device.

At module unload we need to destroy our device node and unregister the character
device numbers. This is done in \texttt{gamepad\_cleanup} and is quite simple.
Basically, every step done in \texttt{gamepad\_init} is undone in reverse order.
The device is destroyed with:

\begin{lstlisting}
	void device_destroy(struct class *class, dev_t devt);
\end{lstlisting}

The class is then destroyed with:

\begin{lstlisting}
	void class_destroy(struct class *cls);
\end{lstlisting}

Then the character device is deleted:

\begin{lstlisting}
	void cdev_del(struct cdev *);
\end{lstlisting}

And finally the character device number is unregistered:

\begin{lstlisting}
	void unregister_chrdev_region(dev_t	from, unsigned count);
\end{lstlisting}

\subsection{Accessing GPIO, Interrupts and Asynchronous Input/Output}

\subsubsection{Reading from the Device}

So there is a character device responding with data when read, but where that
data comes from hasn't been mentioned yet. The data comes from the function set
to the \texttt{read} field of the \texttt{gamepad\_fops} structure. In our
driver this function is

\begin{lstlisting}
	static ssize_t gamepad_read(struct file *filp,
		char __user *buf, size_t count, loff_t *offp)
\end{lstlisting}

Of its parameters, only \texttt{buf} and \texttt{count} are used. \texttt{buf}
is a pointer to a buffer in userspace where data should be transferred.
\texttt{count} is the maximum amount of bytes that should be read into the
buffer. The return value of the function is how many bytes were stored into the
user's buffer. Our driver stores the gamepad status in a global variable
\texttt{uint8\_t status}, so all the \texttt{gamepad\_read} function needs to do
is to copy the value of that one byte into the user's buffer. The driver should
not attempt to write directly into the buffer through the pointer, but rather
use an existing function in the kernel to copy data from the kernel into user
memory:

\begin{lstlisting}
	unsigned long copy_to_user(void __user *to,
	 	const void *from, unsigned long n);
\end{lstlisting}

Where \texttt{to} is \texttt{buf}, \texttt{from} is \texttt{\&status} and
\texttt{n} is 1.

\subsubsection{Hardware IO and Interrupts}

So we can read the \texttt{status} variable from the user application through
the character device, but we still need to read the status from the gamepad into
\texttt{status}. This is done in much the same way as in exercise 2, the GPIO
hardware is initialised by configuring the correct hardware registers. We wish
for the GPIO hardware to issue interrupts on button presses, so in addition to
enabling the GPIO pins we also configure and enable interrupts. In exercise 2 we
wrote directly to the hardware registers. This is not a good idea in a Linux
driver, where the standard interfaces should be utilised to play nicely with
other parts of the system. While it is technically possible to simply write
directly to the hardware registers in this case, due to the microcontroller's
lack of an MCU, we have attempted to follow the standard procedures for writing
to hardware. This procedure involves requesting a region of I/O memory and
remapping the area into memory. This last step does essentially nothing on this
particular system, as the microcontroller has no concept of virtual memory. As a
result the memory area will simple be remapped to its original location. Due to
portability it is still recommended to follow this procedure, however. The two
functions called to achieve this are:

\begin{lstlisting}
	struct resource *request_mem_region(unsigned long start,
		unsigned long len, char *name);

	void *ioremap_nocache(unsigned long phys_addr,
		unsigned long size);
\end{lstlisting}

The pointer to the remapped memory region is stored in a global variable
\texttt{volatile struct efm32gg\_gpio *GPIO}. The \texttt{struct efm32gg\_gpio}
structure describes the layout of the GPIO hardware registers. With the hardware
registers requested and mapped, we can start configuring the GPIO hardware.
Instead of dereferencing \texttt{GPIO} directly, we use another kernel function
, \texttt{iowrite32}, designed to write to I/O memory:

\begin{lstlisting}
	/* configure pins */
	iowrite32(0x33333333, &GPIO->PC.MODEL);
    iowrite32(0xff, &GPIO->PC.DOUT);

	/* configure pin interrupt */
    iowrite32(0x22222222, &GPIO->EXTIPSELL);
    iowrite32(0xff, &GPIO->EXTIFALL);
    iowrite32(0xff, &GPIO->EXTIRISE);

	/* enable gpio interrupts */
    iowrite32(0xff, &GPIO->IEN);
    iowrite32(0xff, &GPIO->IFC);
\end{lstlisting}

The GPIO hardware is now configured and issuing interrupts on button presses
from the gamepad, but we still need to register the interrupt requests with
Linux and tell it what we want to have done when it receives the interrupt. This
is done with:

\begin{lstlisting}
	request_irq(unsigned int irq, irq_handler_t handler,
		unsigned long flags, const char *name, void *dev);
\end{lstlisting}

\texttt{irq} is the number of the interrupt request we wish to register. The
relevant numbers for GPIO even and GPIO odd interrupts are supplied in the
TDT4258 compendium \cite{TDT4528Compendium}. \texttt{handler} is a function
pointer to a callback function which will be invoked when an interrupt request
is fired. We set this to a function in our module named
\texttt{gamepad\_handler}. The interrupt handler uses I/O access functions to
read the status of the controller into \texttt{status} and clear the GPIO
interrupt flags.

Resources allocated to the driver for accessing the hardware registers should
also be freed on module unload. This is also done in \texttt{gamepad\_cleanup}.
Firstly by clearing \texttt{GPIO->IEN} to disable interrupts from the GPIO, then
by calling the following function to free the interrupt request lines we
requested from the kernel:

\begin{lstlisting}
	void free_irq(unsigned int irq, void *dev_id);
\end{lstlisting}

The mapped GPIO hardware registers are subsequently unmapped with:

\begin{lstlisting}
	void iounmap(void * addr);
\end{lstlisting}

And the GPIO hardware memory region is released with:

\begin{lstlisting}
	void release_mem_region(unsigned long start,
		unsigned long len);
\end{lstlisting}

\subsubsection{Asynchronous Input/Output}

We wish for the device driver to be able to signal the user application whenever
a GPIO interrupt occurs. This is achieved in our driver using asynchronous
notification with the SIGIO signal. There is very little additional code that
needs to be added for the device driver to have this functionality. A global
\texttt{struct fasync\_struct *fasync\_queue} is declared to hold a queue of
processes that should be notified of an interrupt. In \texttt{gamepad\_fops} the
\texttt{fasync} field is set to a function \texttt{gamepad\_fasync} and the
\texttt{release} field is set to a function \texttt{gamepad\_release}.
\texttt{gamepad\_fasync} is then invoked every time a user process enables or
disables asynchronous notifications from the file descriptor to our device
driver. The function uses a helper function called \texttt{fasync\_helper} which
adds the process to or removes the process from the queue.
\texttt{gamepad\_fasync} is also issued from \texttt{gamepad\_release}, so that
processes are removed from the queue if they close the device driver. Finally,
in the \texttt{gamepad\_handler} we issue the signal to all listening processes
by invoking:

\begin{lstlisting}
	void kill_fasync(struct fasync_struct **fa,
		int sig, int band);
\end{lstlisting}

With a \texttt{sig} of \texttt{SIGIO}. As a result, all listening processes
receive a SIGIO signal.
