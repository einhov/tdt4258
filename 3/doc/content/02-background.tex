\chapter{Background and Theory}

\section{EFM32GG-DK3750}

As in the two first exercises, the system used for this exercise is the
EFM32GG-DK3750 development board together with the custom gamepad provided.
Exact hardware details are of less importance than in earlier exercises due to
abstraction layers provided by software which will be elaborated upon in
subsequent sections. Specially relevant for this exercise are the gamepad and
GPIO on the EFM32GG, and the EFM32GG-DK3750's LCD. The gamepad is accessed
largely in the same way as in exercise 2, with some complications that will be
made evident later. The LCD is a \(320 \times 240\) pixels large display. For
this exercise it is not necessary to manually program the LCD, as access to it
has been abstracted into a simple interface which is employed to manipulate the
display. The UART is also utilised as a serial connection between the
development board and a computer to enable more advanced interactivity with the
board than the gamepad is capable of supplying. This serial connection is also
managed for us.

\section{Linux and \textmu Clinux}

In exercise 1 and 2 we programmed the development board in an unmanaged
environment, also referred to as \emph{on bare metal}. While coding on bare
metal makes it simple to quickly get code running and gives direct access to
hardware, it also puts the burden of resource management and hardware
configuration on the application programmer. The programmer must make sure to
either initialise the hardware and keep track of resources inside the
application, or to link with and call existing code that performs these tasks.
For many applications the power gained from having direct access to the hardware
is likely to be unnecessary, the required code would be similar boilerplate
replicated in multiple applications and potentially prone for bugs, and the
application programmer must expend mental effort that could have gone towards
development of the application itself. The resulting application would also be
specialised to run on the specific platform it initially targetted and
supporting additional platforms would rapidly increase the complexity of its
complexity. An alternative to programming on bare metal is to develop
applications for an abstraction layer provided by a managed system that does
hardware initialisation and configuration, and manages resources for the the
application programmer. Such a system is called an \emph{Operating System}
(\textbf{OS}).

For this exercise the application was developped to run on an OS based on the
\emph{Linux kernel}. The Linux kernel is an \emph{UNIX-like} kernel, which means
that its interfaces to user applications mimic ones from a family of OSes known
as \emph{UNIX}. Of relevance to this exercise is that, due to Linux' UNIX-like
nature, it closely follows the \emph{POSIX standard}, which gives us a formally
defined API to code for. We will get back to POSIX and introduce the \emph{C
Standard Library} in the next section. The Linux kernel is often paired with a
set of applications, such as a shell and base tools to operate the system, and a
C library to form a complete OS. On desktop PCs, software from the GNU
collection is normally used. On embedded systems, such as in our exercise, the
software in the GNU collection is usually unsuitable due to its size and
performance footprint. The system we programmed for is instead using the
\emph{BusyBox} utilities and \emph{\textmu Clibc} library, which we will get
back to shortly.

The standard Linux kernel is designed to run on processors with a \emph{Memory
Management Unit} (\textbf{MMU}). The MMU is a unit of a CPU responsible for
translating and validating memory accesses. With an MMU a system can, amongst
other functionalities, map \emph{virtual memory addresses} to \emph{physical
memory addresses}, allowing programs to address memory independently of its
physical location, or perform access control to memory based on a program's
priveleges. As the EFM32GG microcontroller on the EFM32GG-DK3750 development
board we are using for the exercise does not have an MMU, we are using a port of
Linux called \textmu Clinux, which is a port of the Linux kernel patched to
function on microcontrollers lacking MMUs. Amongst other things, the \textmu
Clinux kernel handles clocks, timers and interrupts for us, which means that a
lot of the setup code written in exercise 1 and 2 did not need to be written for
exercise 3.

\section{C Standard Library and POSIX}

In addition to having the OS kernel manage resources and hardware, it is also
desireable to have access to a set of common functionalities and an interface to
the kernel from the user application. The first is provided by the C Standard
Library and the latter is mostly covered by the \emph{C POSIX Library}, a
superset of the C Standard Library part of the POSIX Standard. The C Standard
Library provides functionality for common tasks such as mathematical
computations, input/ouput and memory allocation. The C POSIX Library extends on
this with specifications for compatability with UNIX systems. The POSIX Standard
also specifies the operation and behaviour of certain base system utilities. The
toolchain used by the build system utilised for this exercise builds
applications statically linked to the briefly aforementioned \textmu Clibc.
\textmu Clibc is a C libray focused on maintaining a tiny size, intended for use
on embedded systems.

\section{BusyBox}

BusyBox provides base utilities that implement required functionality for
initialising and operating the system after the kernel has booted. The BusyBox
binary is a statically linked program which is symbolically linked to other
binary files. When the BusyBox binary is executed from the various symlinked
files it will select a behaviour based on the name it got started as. Some
essential BusyBox utilities for successfully initialising the system and
starting the game are \texttt{/bin/sh}, \texttt{/bin/mount} and
\texttt{/sbin/modprobe}. \texttt{/bin/sh} is the system shell. The system shell is
an interactive shell the user can use to interact with the system over the
serial connection. The system shell is also the first program to be executed by
the kernel, as it is invoked to execute the shell script named
\texttt{/linuxrc}, which sets up some parts of the system before executing the
interactive shell. \texttt{/bin/mount} mounts filesystems to mountpoints in the
file hierarchy. On the Linux system we're using, the main filesystem is already
mounted to \texttt{/}, but \texttt{/bin/mount} is used during \texttt{/linuxrc}
to mount the \texttt{/proc} and \texttt{/sys} filesystems, which represent
information and interfaces from the Linux kernel as files in the file hierarchy.
\texttt{/sbin/modprobe} is a utility which loads a kernel module into the Linux
kernel, which will be elaborated on later. Further utilities in BusyBox are
mainly useful for interactive usage of the Linux system.

\section{Distributions and PTXdist}

To get a working Linux system on the development board, it is necessary to flash
a few images to the board's flash memory. A platform specific \emph{bootloader}
containing instructions for early initialisation of hardware and loading of the
Linux kernel. Further it is necessary to flash the Linux kernel itself alongside
a platform specific \emph{Device Tree Blob} which describes the hardware
configuration of the targetted platform. Finally a \emph{root file system} image
containing files that should be available on the system at runtime. A manual
construction process to all of this would be tiresome and prone to errors. On
personal computers and many embedded systems, this is solved with pre-assembled
distributions of operating systems. To build the system during this exercise we
employed the \emph{PTXdist} build system. PTXdist is a build system designed to
build tiny Linux distributions for embedded systems. The support files we
received for the exercise included a PTXdist project set up to compile a proper
\textmu Clinux kernel, build a user application stub called \emph{game} and a
Linux module stub called \emph{driver-gamepad}, and to build and flash complete
images of the resulting systems.

\section{Kernel Modules and Device Drivers}

Reading input from the gamepad in Linux is done in largely the same way as in
the previous exercises. There are, however, a few major differences. The user
application \emph{should not}, and in systems where memory is more strictly
managed \emph{can not}, access hardware directly. Rather, the Linux kernel has
to expose the hardware to the user application through some sort of interface.
A piece of code in the kernel responsible for maintaining a hardware device and
exposing its functionality to user applications is called a \emph{device
driver}. The code is part of a \emph{kernel module}, which is a separate unit of
code which can be registered into a running kernel. Each module is written
according to a kernel module interface, so that the kernel knows how to load the
module. Kernel modules for Linux can be configured to be built into the kernel
at compile time or to be compiled into separate dynamically loadable kernel
object files, which are loaded into the kernel with the \texttt{modprobe}
utility.

A device driver exports an interface to the device through the \texttt{/sys}
filesystem and through \emph{device nodes} in \texttt{/dev}. In the device
driver implemented in this exercise, only a \emph{device} node in \texttt{/dev}
been utilised. To the user application a device node appears like a normal file
which can be accessed with regular file input/input functions. When the user
application performs reads or writes on the device file, the requests are
relayed to specified functions within the device driver. Thus the device driver
can transfer data to and from the kernel, and by extension hardware, by request
from user applications. In addition to the main funtionality of reading and
writing device files, there is also an alternative interface through the device
file through the \texttt{ioctl} system call. While not used in our gamepad
driver, the \texttt{ioctl} call is used while drawing into the framebuffer.

\section{Framebuffer}

The LCD on the development board is exposed to user applications through the
\emph{fbdev} device driver. The driver registers a device node \texttt{/dev/fb0}
which exposes a \emph{framebuffer}. The framebuffer is an area of memory
representing the contents of the display. If data is written into the
framebuffer, the display will reflect this by displaying the written data as
pixels. The framebuffer exposed by fbdev on the EFM32GG-DK3750 has a resolution
of \(320 \times 240\) pixels. Each bit has a depth of 16 bits. Colours are
encoded additively as a combination of red, green and blue intensities, where
each colour has a depth of 5, 6 and 5 bits respectively. This pixel format is
commonly known as \emph{RGB565}.
