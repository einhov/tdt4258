\chapter{Background and Theory}

The problem is to be solved on the EFM32GG-DK3750 Development Kit from Energy
Micro. The kit contains the EFM32GG990F1024 MCU, a motherboard with various
peripherals, and a prototyping board for connecting external devices.
\cite{DK3750Manual} Further we are also using a custom gamepad made specifically
for the course. To develop and profile the software for the kit we are using the
GNU toolchain and selected tools from the energyAware software suite.

\section{The MCU}

The MCU contains a CPU core from the ARM Cortex-M3 family, 1MB of Flash memory,
128kB of SRAM, a debug interface, an interrupt controller and various
peripherials. Amongst the peripherials are clocks, I/O ports and timers.
For solving this problem we will only need peripherals from
these categories, but the MCU also contains serial interfaces, analog
interfaces, an energy management unit and hardware acceleration for AES
encryption. The Flash memory, SRAM and peripherals are all mapped to the CPU's
system memory map. \cite{EFM32GGManual}

The MCU operates in different energy modes, named EM0 through EM4. At EM0,
called Run Mode, the CPU and all peripherals are active. At EM1, called Sleep
Mode, the CPU is halted in a sleep mode, but all peripherals are still active.
In higher modes, sets of peripherals are deactivated to further lower energy
consumption. Entering a lower energy mode must be done in software, using the
wfi and wfe instructions. Returning to EM0 and waking the CPU is initiated with
an event or interrupt to the CPU. \cite{EFM32GGManual}

\section{Motherboard}

The kit's motherboard hosts the MCU module and the prototyping board, along with
various other peripherals. Of relevance to this exercise is the Advanced Energy
Monitoring (\textbf{AEM}) system, which provides tracking of energy consumption.
There is also an LCD display, buttons and a joystick which are used to configure
the kit and display an energy consumption graph. Energy consumption can also be
tracked from a computer connected over USB. \cite{DK3750Manual}

\section{Prototyping Board and Controller}

The prototyping board provides contacts for connecting external circuits to the
dev kit. \cite{DK3750Manual} For this exercise we are connecting the controller
to two sets of GPIO pins on the board, each set consisting of 8 pins. One set of
pins is used for input from the controller's 8 buttons, while the other set is
used for setting 8 LED lights on the controller board.

\section{Software}

As mentioned two sets of software were primarily used to develop the program for
the dev kit. The GNU toolchain is a set of tools for building executable code
from source code. The toolchain also provided a debugger that was used in
conjunction with a debugging server from the energyAware software suite to debug
the program on the MCU. Other tools from the energyAware software suite was used
to upload the program to the MCU's flash memory, and to read energy consumption
information from the AEM. \cite{TDT4528Compendium}

GNU Compiler Collection
The compiler we will be using to 
We will also be using a complex piece of software, GNU Compile Collection, which 
would compile our current C programs into an object file. 

\section{Sound Generator}

In this excercise, we will use the Digital to Analog Converter (DAC) that is a
part of the EFM32GG and is connected to an amplifier on the DK3750 development
board. \cite{TDT4528Compendium} The DAC converts a digital value to an analog
output voltage, using a limited amount of energy and thus maintaining a low
energy consumption. Using DMA (Direct Memory Access) and a timer, the DAC should
be able to generate waveforms without any CPU intervention. The DAC has two
channels (Channel 0 and 1) with 12-bit data registers (DACn_CH0DATA and
DACn_CH1DATA) which may be used to produce two independent outputs. The three
conversion modes the DAC supports are continous, sample/hold and sample/off.
Continous mode have the DAC channels drive their outputs continously, which
maintain the output voltage and makes refresh not needed. Sample/hold mode is
only active while the DAC core is triggered and is turned off otherwise.
Therefore there may be needed for a refresh conversion if a certain period of
time is passed. For the sample/off mode the DAC is off between samples, which
requires the output voltage to be stored externally as the DAC is turned off
after the conversion. The channels in the DAC have also a possibility of being
either two single ended output or a differential output. In the single ended
output scenario the channels (0 and 1) have their respective outputs in
DACn_OUT0 and DACn_OUT1. In a scenario with a differential output the data used
is from the 12-bit register used by channel 0 (DACn_CH0DATA) and the output is
bipolar voltage with the positive output on DACn_OUT1 and the negative output on
DACn_OUT0.















