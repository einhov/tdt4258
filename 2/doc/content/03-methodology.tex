\chapter{Methodology}

\section{Implementation}

\subsection{Overview}

Our program plays a looping melody made by a frequency modulated, generated
square wave signal, while also playing up to four simultaneous sound samples
when gamepad buttons are pressed. The functionality is spread over the following
C source files.

\begin{description}
\item[ex2.c] \hfill \\
	Glues all the logic together. Contains the reset handler and logic for
	calculating audio samples for the DAC. The DAC is also set up here.
\item[crt.c] \hfill \\
	Useful utility functions.
\item[init.c] \hfill \\
	Initialisation code for the system.
\item[gpio.c] \hfill \\
	Initialisation code and interrupt handler for the gamepad. This file also
	contains code to queue sound samples for playback.
\item[letimer.c] \hfill \\
	Initialisation code and interrupt handler for the LETIMER and LFRCO.
\item[waveform.c] \hfill \\
	Sound signal generators for sawtooth, square and triangle waveforms.
\item[sound.c] \hfill \\
	Code for playing back sound samples.
\end{description}

\subsection{Register structures}

To easily access the hardware registers on the EFM32GG we set up a number of
struct definitions in efm32gg.h for the various register sets. We then declared
the register sets we needed as external volatile struct variables and defined
their addresses in the efm32gg.ld linker script included in our main linker
script. This allowed us to easily access the hardware registers with proper
type-checking from C. This method also gave us enhanced debugging functionality,
as GDB understands C structures. For example, a \texttt{print GPIO} statement in
the GDB console would print the values of all the registers of the GPIO
peripheral. In this chapter we have used the struct member access syntax to
refer to registers, for instance \texttt{CMU.HFPERCLKEN0}.

\subsection{Initialisation}

Initialisation of the system is spread throughout many of the source files. All
initialisation is done in the reset handler, \_start, located in ex2.c. The
reset handler calls initialisation functions from other source files. First the
.bss section of memory is cleared with 0 bytes and the .data section is copied
from Flash storage to memory. The HFRCO clock is then increased to 28MHz by
writing 5 to the band selection field of the CMU.HFRCOCTRL register. GPIO is
initialised as in exercise 1; the GPIO peripheral is enabled, configured and its
interrupt signals are unmasked in the NVIC. The DAC0 peripheral is then enabled
and configured, enabling both channels of the DAC. Further the LETIMER is
initialised, clocked by the LFRCO. The LFRCO is enabled by setting bit 6 of
CMU.OSCENCMD and bit 7 of CMU.STATUS, which indicates that the LFRCO is ready,
is read in a loop until it is set. Then Low Energy Peripherals are enabled by
setting bit 4 of CMU.HFCORECLKEN0 and the LETIMER peripheral is enabled by
setting bit 2 of CMU.LFACLKEN0. The LETIMER is configured to count down with a
TOP value of 1, resulting in a \(\frac{32768}{2} = 16384\)Hz interrupt rate,
enabled and unmasked in the NVIC. Finally, we turn off the three upper RAM
blocks, configure the MCU for deep sleep mode and enter a wait for interrupt
loop.

\subsection{Waveforms}

The waveforms program has code for generating sawtooth, square and triangle
waveforms. Each waveform generation function takes a pointer to a voice
structure for the waveform. The voice structures contain, at least, the current
frequency and phase of the voice. The waveform generator calculates the correct
sample based on this structure and updates the phase. In our final program we
only use the square wave generator. Its output value is set to a constant
PEAK\_AMP if the voice's phase is below \(\frac{PEAK\_AMP}{2}\) and zero
otherwise. For every invocation the generator increments the phase by
\(\frac{PEAK\_AMP \times frequency}{SAMPLE\_RATE}\), where \(frequency\) is the
frequency of the voice and \(SAMPLE\_RATE\) is the constant sample rate of the
signal, which in our case is the LETIMER interrupt rate. This means that, as
long as the generator is called with the voice every timer tick, the voice will
go through \(frequency\) periods every second and samples from the first half of
each period will be PEAK\_AMP and the second half zero, resulting in a square
wave of the intended frequency.

\subsection{Sound samples}

The sound samples our program plays are stored as raw 8-bit, 16384Hz, single
channel, unsigned integer values. The source files in .wav format are converted
to this raw format with the \emph{Sound eXchange} program (\textbf{SoX}). (Fig.
\ref{Makefile:soundconvert}
\begin{figure}[h]
	\label{Makefile:soundconvert}
	\begin{lstlisting}
%.raw : %.wav
	${SOX} $< -r 16384 -b 8 -c 1 -e unsigned-integer $@
	\caption{Converting sounds to raw in Makefile}
	\end{lstlisting}
\end{figure}
The raw files are further linked into object files with the linker ld. Invoking
ld as shown in fig. \ref{Makefile:soundlink} creates an object file with the
binary input stored in the .data section and defines symbols to the start of the
data, end of the data and the size of the data.
\begin{figure}[h]
	\label{Makefile:soundlink}
	\begin{lstlisting}
%.o : %.raw
	${LD} -r -b binary $< -o $@
	${OBJCOPY} --rename-section .data=.rodata,readonly,data,content $@ $@
	\caption{Linking sounds in Makefile}
	\end{lstlisting}
\end{figure}
Unfortunately, when ld is invoked like this the binary data is placed in the
.data section of the object file by default. We want the data in the .rodata
section so that it is stored on and read from the Flash memory. As also seen in
fig. \ref{Makefile:soundlink}, we fix the object file by using objcopy to rename
the .data section to .rodata. The symbols defined by the binary linking are
formated as \emph{\_binary\_\textbf{filename}\_\textbf{extension}\_start} and
similar for end and size. In the code these symbols are declared as extern const
char arrays with the EXTERNBINARY (fig \ref{code:externbinary} macro.
\begin{figure}[h]
	\label{code:externbinary}
	\begin{lstlisting}
#define EXTERNBINARY(x,y)  \
	extern const char _binary_##x##_##y##_start[]; \
	extern const char _binary_##x##_##y##_end[]; \
	\caption{EXTERNBINARY macro from sound.h}
	\end{lstlisting}
\end{figure}

To play back the sounds a function play\_sound is used. As input it takes a
pointer to a struct sound. The struct represents a particular playback of the
sound sample. It contains the start and end positions of the audio, along with a
counter storing where in the sound the playback currently is. The play\_sound
function returns the next sample value and increments the position counter. If
the position counter is at the end of the sound, the function will either,
depending on a bool input, set the position back to 0, causing the sound to
loop, or return 0.

\subsection{Playing music and sounds}

The function dac\_feeder in ex2.c is called from the LETIMER interrupt handler
and is responsible for feeding the DAC and some general bookkeeping for sounds
and music. The output sample value is calculated by accumulating samples from
the various sources in a variable sample. After all sources have been added to
the sample variable, its volume is scaled by right shifting the variable by
another variable volume, before getting sent to the DAC by writing it to
DAC0.CH0DATA and DAC0.CH1DATA. The volume variable is incremented and
decremented in the GPIO interrupt handler on certain button presses, so that the
overall volume of the program can be changed by the user.

The music in our final program is a single square voice that constantly screams
at varying frequencies. Notes are represented in a struct note which contains a
start frequency and an end frequency. We store the end frequency so that we can
interpolate between the frequencies to get a sliding note. The melody is stored
as an array of these sound structs. The LETIMER interrupt handler increments a
tick variable every time it fires. The dac\_feeder uses this variable to keep
track of the position in the song. It does this by calculating an index in the
song array with the formula \( \frac{\texttt{tick}}{8192} \% \texttt{song\_size}
\). The value \( 8192 \) is half the sample rate, or half the LETIMER interrupt
rate, and each note is therefore half a second long. After finding the corrent
note, the frequency of the square voice is set to a linear interpolation between
the note's start and end frequency. After the frequency has been set, the square
voice is calculated by a call to the square\_wave function and added to the
sample accumulator.

Code for playing sound samples on controller button presses is spread between
the dac\_feeder in ex2.c and the GPIO interrupt handler in gpio.c. An array
sounds of four sound structs is defined in ex2.c. In response to a button press
on the controller, the GPIO interrupt handler checks the sounds array for a free
spot. A free spot in the array is defined as an entry whose start data address
is null. If a free spot is found, it will copy the values of a sound struct with
data about the sound corresponding to the pressed button into the free spot and
set its time value to zero. If no free space is found in the array, the input is
ignored. Every LETIMER interrupt the dac\_feeder iterates through the sounds
array and calls play\_sound on any active sounds, that is an entry in the array
whose data start value is not null, it finds, adding the result to the sample
accumulator. After playing a sound it checks whether the sound has finished, by
comparing its counter value to the size of the sound. If the sound has finished
its data start value is set to null, to free up the slot in the array.

\section{Testing}

Due to the fact that this exercise is in several ways similar to exercise 1, we
already had a certain degree of knowledge on how to set up the EFM32GG.
Therefore we had a pretty early opportunity to test the sounds by pressing
buttons on the gamead. This made us aware of how the sound was affected by
different sample rates on the sounds. We used agile testing, which mean that we tested
several different values and when we found something that worked, moved on to a
different value. This is not necessarily clean method, but it produces quick
results. This gave us the ability to change based on a working formula and
changing it to our liking.
