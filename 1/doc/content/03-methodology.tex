\chapter{Methodology}

\section{Implementation}

Most of the implementation involves manipulation of hardware registers of
involved peripherals. Names of the registers as they appear in this report have
been taken from the EFM32GG Reference Manual. \cite{EFM32GGManual} Register names
follow a pattern of {\tt SUBSYSTEM\_REGISTERNAME}. For instance, the Control
Register of the CMU is called  {\tt CMU\_CTRL}. Names for individual fields
inside the registers have also been taken from the manual. When referring to the
Debug Clock selector field of the {\tt CMU\_CTRL} register, we write {\tt
CMU\_CTRL[DBGCLK]}.

However, before we could start playing with the peripherals, we had to get some
code to run at all. The CPU uses an \emph{Exception Vector Table} containing
addresses to exception handlers to know what code that should be executed when
different exceptions are triggered in the CPU. \cite{CortexM3Manual} The Vector
Table also contains the initial address for the top of the stack. At system
reset the CPU will start executing the reset handler. We populated the Exception
Vector Table with an initial stack address, the address of our reset function
and filled the rest with the address of a dummy handler that does nothing. Our
initial reset function just a branch to itself, looping forever and doing
nothing.

Our implementation has tried to follow the ARM ABI for register usage, register
synonyms and function parameter passing conventions. \cite{ARMArchitecture}

\subsection{Let there be light}

As the goal of this exercise was to manipulate the LED lights on the controller
board in some way according to button input, a natural starting point is to get
some lights enabled. From system reset most peripherials of the MCU were
disabled, so in order to light the LEDs we first had to enable the GPIO
peripherals in the MCU's \emph{Clock Management Unit} (\textbf{CMU}).
\cite{EFM32GGManual} To enable the GPIO peripherals we set {\tt
CMU\_HFPERCLKEN0[GPIO]} to 1. (Fig \ref{code:settingregister})

\begin{figure}[h]
	\caption{Setting a bit in a memory-mapped register}
	\label{code:settingregister}
	\begin{lstlisting}[frame=single]
	ldr a1, =CMU_BASE
	mov a2, #(1<<CMU_HFPERCLKEN0_GPIO)
	str a2, [a1, #CMU_HFPERCLKEN0]
	\end{lstlisting}
\end{figure}

After enabling the GPIO system we configured the LED lights' GPIO pins to drive
output to the LEDs. The LEDs are connected to GPIO port A and are configured
with the {\tt GPIO\_PA\_x} registers. First we set the drive strength to high by
writing 2 to {\tt GPIO\_PA\_CTRL}. Further we set all the pins as output pins
based on the drive strength, by setting all fields of {\tt GPIO\_PA\_MODEH} to
{\tt PUSHPULLDRIVE}. At this point the pins were properly configured, and we
could turn on lights by clearing bits 15:8 of {\tt GPIO\_PA\_DOUT}.

\subsection{Reading input and interrupts}

The steps to enable input from the GPIO pins of port C connected to the
controller board's buttons were similar to those for enabling the LEDs. We set
the pins to a proper mode by setting all pins of {\tt GPIO\_PC\_MODEL} to {\tt
INPUTPULL} and made the pins active high by setting bits 7:0 of {\tt
GPIO\_PC\_DOUT}. After this we could poll {\tt GPIO\_PC\_DIN} for status of the
individual buttons.

Polling the {\tt GPIO\_PC\_DIN} register for button status works fine, but it is
very wasteful to have the CPU constantly run in a loop to regularily do so. It
would be better if we could have the CPU be told when a button is pressed. There
is support for this in the GPIO peripheral and in the CPU. The GPIO peripheral
can be configured to issue an interrupt to the CPU when a GPIO pin is pulled
high or low. Upon receiving this interrupt the CPU will execute code from the
address set as the GPIO handlers in the Vector Table, which we pointed to a
function we wrote named {\tt gpio\_handler}. By writing 2 to all the fields of
{\tt GPIO\_EXTIPSELL} we selected that the GPIO interrupts 0-7 all should be
driven by pins from GPIO port C. We wanted the buttons to issue interrupts when
pressed and not when released. To get this behaviour we found out that we had to
configure the pins to issue an interrupt on a falling edge and to not issue an
interrupt on a rising edge. This was done by setting bits 7:0 of {\tt
GPIO\_EXTIFALL} and leaving bits 7:0 of {\tt GPIO\_EXTIRISE} clear.  The final
step necessary in the GPIO peripheral was to enable interrupts for the GPIO
pins, by setting bits 7:0 of {\tt GPIO\_IEN}. Finally, GPIO interrupts must be
enabled in the CPU's \emph{Nested Vector Interrupt Controller} (\textbf{NVIC}).
This was done by setting the two bits corresponding to the odd- and even GPIO
exceptions of the NVIC's {\tt ISER0} (Interrupt Set-Enable) register. Following
this, pressing a button on the controller would cause the GPIO exception handler
function to be executed.

Now that we had the ability to run code on demand by pushing buttons, we were
set to manipulate the lights with the controller. We wrote a function {\tt
rotate\_leds} that read the current status of the LED GPIO pins from {\tt
GPIO\_PA\_DOUT}, bitwise negated the value, and wrote back to the register.
Branching to this function from {\tt gpio\_handler}, we would now flip the LEDs
on the controller board every time we pushed a button on the controller.

\begin{figure}[h]
	\caption{\texttt{rotate\_leds}}
	\label{code:rotate_leds}
	\begin{lstlisting}[frame=single]
	.thumb_func
	.type  rotate_leds, %function
	.globl rotate_leds
rotate_leds:
	ldr a1, =GPIO_PA_BASE
	ldr a2, [a1, #GPIO_DOUT]
	mvn a2, a2
	str a2, [a1, #GPIO_DOUT]
	bx lr
	\end{lstlisting}
\end{figure}

\subsection{BSS}

We soon come to a part of the implementation that uses read-write variables
stored in SRAM. Our code expects its variables to be zero upon system reset, but
the MCU does not take care of this for us. Therefore we had to write code that
sets the memory cells of all our SRAM variables to 0. We implemented this as a
loop in the {\tt bss\_zero} function (Fig \ref{code:zero_bss}) and called this
early in the program. Start and end addresses for the BSS section of memory are
defined in the linker script for the final executable and resolved at link time.

\begin{figure}[h]
	\caption{\texttt{zero\_bss}}
	\label{code:zero_bss}
	\begin{lstlisting}[frame=single]
	.thumb_func
zero_bss:
	ldr a1, =_sbss
	ldr a2, =_ebss
	mov a3, #0
zero_loop:
	str a3, [a1], #4
	cmp a1, a2
	blo zero_loop
	bx lr
	\end{lstlisting}
\end{figure}

\subsection{Timers}

Flipping lights with buttons is all quite exciting, but we wanted the lights to
flip on their own. A na\"{\i}ve solution to this problem is to run a loop in the
main thread that calls {\tt rotate\_leds} every \textit{N}th iteration. This is
not a very good solution, as we will see later when we wish to put the CPU to
sleep to reduce energy consumption. Luckily the MCU contains various timers that
we can use to keep track of time and schedule interrupts. After experimentation
we ended up settling on the \emph{Low Energy Timer} (\textbf{LETIMER0}) due to
its availability in EM2. The timer has to be backed by a clock, in our case we
chose to use the \emph{Low Frequency RC Oscillator} clock (\textbf{LFRCO}
clock).

First we turned on the LFRCO. This was done by setting {\tt
CMU\_OSCENCMD[LFRCOEN]}. The clock will take some time to initialise and become
stable, so after enabling it we read {\tt CMU\_STATUS} in a loop until {\tt
CMU\_STATUS[LFRCORDY]} is set, which signals that the clock is initialised and
stable. With the LFRCO clock running we turned to setting up the timer, but
first we had the enable the LETIMER0 peripheral, and also low energy peripherals
in general. First, to enable low energy peripherals we set the {\tt
CMU\_HFCORECLKEN0[LE]} bit. After the low energy peripherals were enabled, we
set the {\tt CMU\_LFACLKEN0[LETIMER0]} bit to enable LETIMER0.

The LETIMER0 can be operated in various modes. For our usage we used a mode
where the timer to counts forever from a top value towards zero and upon
reaching zero issues an interrupt to the CPU and starts counting again from the
top value. To select this mode we set {\tt LETIMER0\_CTRL[COMP0TOP]} to use the
{\tt LETIMER0\_COMP0} register as the TOP value. We left {\tt
LETIMER0\_CTRL[REPMODE]} cleared as that left it in the counting mode we
intended to use. {\tt LETIMER0\_COMP0} was then loaded with the TOP value, which
in our solution is 4096. As the LFRCO clock has a frequency of 32768 Hz, this
gave our timer an underflow frequency of \( \frac{32768}{4096} = 8 \) Hz. This
means that our timer will interrupt the CPU 8 times every second. Finally we
enabled interrupt on underflow by setting {\tt LETIMER0\_IEN[UF]} and started
the timer by setting {\tt LETIMER0\_CMD[START]}.

At this point we had a timer issuing interrupts, but no handler for the
interrupts, nor is the interrupt enabled in the NVIC. We wrote a function {\tt
letimer\_handler} and registered it as the handler for interrupts from the
LETIMER in the Interrupt Vector Table. {\tt letimer\_handler}'s primary task is
to increment a variable {\tt tick} stored in memory. The {\tt LETIMER0\_IFC[UF]}
bit is also cleared so the system knows the inerrupt has been handled. If \(
{\tt tick} \equiv 0 \pmod 8 \) the {\tt rotate\_leds} function is also called.
(Fig \ref{code:mod})
We then enabled the LETIMER0 interrupt in the NVIC by setting {\tt
ISER0\_LETIMER0} and obtained lights flipping at 1Hz.

\begin{figure}[h]
	\caption{\( {\tt tick} \equiv 0 \pmod 8 \) check in optimised asm}
	\label{code:mod}
	\begin{lstlisting}[frame=single]
	lsls a2, #29     // a2 = tick
	it eq
	bleq rotate_leds
	\end{lstlisting}
\end{figure}

\subsection{The Konami Code}

The goal we set was to change the pattern of the LED lights when a certain
sequence of button inputs were given. The exact sequence we implemented is a
well known cheat code from the mid-1980s called the Konami Code. To recognise
the code we wrote a simple state machine in a function {\tt konami}. The
function uses a constant array {\tt konami\_code} of input values for the code
and a global index variable {\tt konami\_current} to keep track of progress
through the code. It takes a button value as input, compares it to {\tt
konami\_code[konami\_current]} and acts based on whether it is the next button
in the sequence; if the button is correct {\tt konami\_current} is incremented,
if it is incorrect it is set back to 0. If {\tt konami\_current} goes past the
end of {\tt konami\_code} we clear bits 15:8 of {\tt GPIO\_PA\_DOUT} to turn all
the LEDs on. We then called this function from {\tt gpio\_handler} with the
pressed button as argument.

\subsection{Debounce}

During implementation we discovered that the controller board was not a flawless
piece of hardware engineering. The GPIO controller would frequently detect
multiple falling edges per button press, causing our program to see spurious
inputs. This was for obvious reasons not ideal for our code recognition program.
In an attempt to make the controller input more reliable we came up with a
method to debounce the signal in software. In our {\tt gpio\_handler} we
recorded the value of {\tt tick} into a new variable {\tt last\_input} when we
accepted input as genuine and on every invocation checked the current {\tt tick}
to {\tt last\_tick}. If \({\tt tick} > {\tt last\_tick}\) we accepted the button
press as genuine. As {\tt tick} increments at 8Hz this means that inputs
registered within \(8^{-1} = 0.125\)s of a genuine input was dropped. Having
this finer-grained tick counter is the reason we opted for an 8Hz timer
interrupt rather than running it at 1Hz.

\subsection{Energy optimisations}

Our solution uses various techniques to use as little energy as possible. Most
important is putting the CPU to sleep when not in use. This is done by issuing a
a {\tt wfi} instruction in the main thread instead of looping forever.
\cite{CortexM3Manual} By default this will drop the MCU into EM1. However, the
LETIMER0 is a low energy peripheral that is active also in EM2. For our program
we can thus configure the \emph{Energy Management Unit} (\textbf{EMU}) to enter
EM2 instead of EM1. We did this by setting the {\tt SLEEPDEEP} bit of {\tt SCR},
the \emph{System Control Register}. We also set the {\tt SLEEPONEXIT} bit to
automatically go back to sleep after returning from an exception, rather than
having the main thread wake up and looping into a new {\tt wfi}.

Two smaller energy optimisations in the final program are turning off unused
SRAM blocks and enabling zero wait-state reads from Flash. The unused SRAM
blocks were powered down by writing {\tt BLK123} to {\tt EMU\_MEMCTRL}. Zero
wait-state reads only work properly with a core clock below 16MHz. By default
the core clock is 14MHz, but can according to the MCU documentation be unstable
for a short period of time after reset. Therefore, before enabling the zero
wait-state reads we wait for {\tt CMU\_STATUS[HFRCORDY]} to be sure that we are
below 16MHz. Afterwards we set {\tt MSC\_READCTRL[MODE]} to 0 to enable zero
wait-state reads.

\section{Testing}

We tested our program in two domains; correctness and energy efficiency. Testing
for correctness was mostly done with the GNU toolchain tool \emph{gdb}. Using
gdb we could pause the program at will or at specific points in the code with
breakpoints. We could also inspect and modify register- and memory values at
runtime. gdb also let us step through our program one instruction at a time. To
verify that our debouncer actually did something we wrote additional code that
updated counts of genuine and spurious inputs. Testing power efficiency was done
with the eAProfiler tool from the energyAware suite. It allowed us to easily log
a few seconds of energy constumption data and gave us an average consumption of
a time period.
